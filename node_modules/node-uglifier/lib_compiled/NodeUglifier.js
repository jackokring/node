// Generated by CoffeeScript 1.7.1
(function() {
  var Errors, Graph, NodeUglifier, UGLIFY_SOURCE_MAP_TOKEN, UglifyJS, cryptoUtils, fs, fsExtra, packageUtils, path, saltLength, sugar, util, _;

  Errors = require("./libs/Errors");

  Graph = require("./libs/js-graph-mod/src/js-graph");

  fsExtra = require('fs-extra');

  fs = require('fs');

  _ = require('underscore');

  sugar = require('sugar');

  path = require('path');

  packageUtils = require('./libs/packageUtils');

  cryptoUtils = require('./libs/cryptoUtils');

  UglifyJS = require('uglify-js');

  util = require("util");

  saltLength = 20;

  UGLIFY_SOURCE_MAP_TOKEN = "UGLIFY_SOURCE_MAP_TOKEN";


  /* mergeFileFilter */

  NodeUglifier = (function() {
    function NodeUglifier(mainFile, options) {
      var _i, _results;
      if (options == null) {
        options = {};
      }
      this.options = {
        mergeFileFilter: [],
        newFilteredFileDir: "./lib_external",
        containerName: "cachedModules",
        rngSeed: null,
        licenseFile: null,
        fileExtensions: ["js", "coffee", "json"],
        suppressFilteredDependentError: false
      };
      _.extend(this.options, options);
      this.mainFileAbs = path.resolve(mainFile) || path.resolve(process.cwd(), mainFile);
      if (!fs.existsSync(this.mainFileAbs)) {
        throw new Error("main file not found " + this.mainFileAbs);
      } else {
        console.log("processing main file: " + this.mainFileAbs);
      }
      this.salt = cryptoUtils.generateSalt(saltLength);
      this.hashAlgorithm = "sha1";
      this.wrappedSourceContainerName = this.options.containerName;
      this.serialMappings = cryptoUtils.shuffleArray((function() {
        _results = [];
        for (_i = 0; _i <= 10000; _i++){ _results.push(_i); }
        return _results;
      }).apply(this), this.options.rngSeed);
      this._sourceCodes = {};
      this.statistics = {};
      this.lastResult = null;
    }

    NodeUglifier.prototype.getSourceContainer = function(serial) {
      return this.wrappedSourceContainerName + "[" + this.serialMappings[serial] + "]";
    };

    NodeUglifier.prototype.getRequireSubstitutionForMerge = function(serial) {
      return this.getSourceContainer(serial) + ".exports";
    };

    NodeUglifier.prototype.getNewRelativePathForFiltered = function(pathAbs) {
      return path.join(this.options.newFilteredFileDir, path.basename(pathAbs));
    };

    NodeUglifier.prototype.getRequireSubstitutionForFiltered = function(pathAbs) {
      var relFile, relFileNoExt;
      relFile = this.getNewRelativePathForFiltered(pathAbs);
      relFileNoExt = relFile.replace(path.extname(relFile), "");
      return "require('./" + relFileNoExt.replace("\\", "/") + "')";
    };

    NodeUglifier.prototype.addWrapper = function(source, serial) {
      var firstLine, lastLine, modulesArrayStr, secondLine;
      modulesArrayStr = this.getSourceContainer(serial);
      firstLine = modulesArrayStr + "={exports:{}};" + "\n";
      secondLine = "(function(module,exports) {";
      lastLine = "}).call(this," + modulesArrayStr + "," + modulesArrayStr + ".exports);";
      return "\n" + firstLine + secondLine + source + lastLine;
    };

    NodeUglifier.prototype.merge = function() {
      var depGraph, edgeToRemove, filteredOutFiles, firstLine, iter, me, r, recursiveSourceGrabber, wasCycle, _this;
      _this = this;
      firstLine = "var " + this.wrappedSourceContainerName + "=[];";
      r = {
        source: firstLine,
        filteredOutFilesObj: {},
        sourceMapModules: {},
        pathOrder: [],
        cycles: []
      };
      depGraph = new Graph();
      filteredOutFiles = packageUtils.getMatchingFiles(this.mainFileAbs, this.options.mergeFileFilter);
      recursiveSourceGrabber = function(filePath) {
        var ast, basename, filteredOutFilesObj, isSourceObjDepFiltered, isSourceObjFiltered, me, msg, otherSerial, pathSaltedHash, replacement, requireStatement, requireStatements, source, sourceObj, sourceObjDep, _i, _len;
        try {
          depGraph.addNewVertex(filepath, filepath);
        } catch (_error) {
          me = _error;
        }
        source = packageUtils.readFile(filePath).toString();
        pathSaltedHash = cryptoUtils.getSaltedHash(filePath, _this.hashAlgorithm, _this.salt);
        if (_this._sourceCodes[pathSaltedHash] == null) {
          _this._sourceCodes[pathSaltedHash] = {
            source: source,
            serial: _.keys(_this._sourceCodes).length,
            sourceMod: source
          };
          console.log(filePath + " added to sources ");
        }
        sourceObj = _this._sourceCodes[pathSaltedHash];
        isSourceObjFiltered = filteredOutFiles.filter(function(fFile) {
          return path.normalize(fFile) === path.normalize(filePath);
        }).length > 0;
        ast = packageUtils.getAst(source);
        requireStatements = packageUtils.getRequireStatements(ast, filePath, _this.fileExtensions);
        requireStatements.each(function(o, i) {
          return requireStatements[i] = _.extend(o, {
            pathSaltedHash: cryptoUtils.getSaltedHash(o.path, _this.hashAlgorithm, _this.salt)
          });
        });
        for (_i = 0, _len = requireStatements.length; _i < _len; _i++) {
          requireStatement = requireStatements[_i];
          try {
            depGraph.addNewVertex(requireStatement.path, null);
          } catch (_error) {
            me = _error;
          }
          try {
            depGraph.addNewEdge(filePath, requireStatement.path);
          } catch (_error) {
            me = _error;
          }
          sourceObjDep = _this._sourceCodes[requireStatement.pathSaltedHash];
          if (isSourceObjFiltered && packageUtils.getIfNonNativeNotFilteredNonNpm(requireStatement.path, filteredOutFiles, _this.options.fileExtensions)) {
            msg = "filtered files can not have dependency on merged files, file: " + filePath + " dependency: " + requireStatement.path;
            if (_this.options.suppressFilteredDependentError) {
              console.warn(msg);
            } else {
              throw new Error(msg);
            }
          }
          if (sourceObjDep == null) {
            recursiveSourceGrabber(requireStatement.path);
          }
          sourceObjDep = _this._sourceCodes[requireStatement.pathSaltedHash];
          if (sourceObjDep == null) {
            throw new Error(" internal should not happen 1");
          }
          otherSerial = sourceObjDep.serial;
          isSourceObjDepFiltered = filteredOutFiles.filter(function(fFile) {
            return path.normalize(fFile) === path.normalize(requireStatement.path);
          }).length > 0;
          if (isSourceObjDepFiltered) {
            replacement = _this.getRequireSubstitutionForFiltered(requireStatement.path);
          } else {
            replacement = _this.getRequireSubstitutionForMerge(otherSerial);
            r.sourceMapModules[_this.getSourceContainer(otherSerial)] = path.relative(path.dirname(_this.mainFileAbs), requireStatement.path);
          }
          sourceObj.sourceMod = packageUtils.replaceRequireStatement(sourceObj.sourceMod, requireStatement.text, replacement);
        }
        if (isSourceObjFiltered) {
          basename = path.basename(filePath);
          if (r.filteredOutFilesObj[basename]) {
            filteredOutFilesObj = r.filteredOutFilesObj[basename];
            if (filteredOutFilesObj.serial !== sourceObj.serial) {
              throw new Error(" external files with same filename not supported yet");
            }
          } else {
            r.filteredOutFilesObj[basename] = {
              pathRel: _this.getNewRelativePathForFiltered(filePath)
            };
            return _.extend(r.filteredOutFilesObj[basename], sourceObj);
          }
        } else {
          if (sourceObj.serial > 0) {
            sourceObj.sourceModWrapped = _this.addWrapper(sourceObj.sourceMod, sourceObj.serial);
          } else {
            sourceObj.sourceModWrapped = sourceObj.sourceMod;
          }
          r.pathOrder.push(filePath);
          return r.source = r.source + sourceObj.sourceModWrapped;
        }
      };
      recursiveSourceGrabber(this.mainFileAbs);
      this.lastResult = r;
      wasCycle = true;
      iter = 0;
      while (wasCycle && iter < 1000) {
        iter++;
        wasCycle = false;
        try {
          depGraph.topologically(function(vertex, vertexVal) {});
        } catch (_error) {
          me = _error;
          wasCycle = true;
          if (me.cycle) {
            r.cycles.push(me.cycle);
            edgeToRemove = [me.cycle.last(2).last(), me.cycle.last(2).first()].reverse();
            depGraph.removeEdge.apply(depGraph, edgeToRemove);
          }
        }
      }
      if (!_.isEmpty(r.cycles)) {
        throw new Errors.CyclicDependencies(r.cycles);
      }
      return this;
    };

    NodeUglifier.prototype.exportDependencies = function(exportDir, srcDirMap) {
      var baseDir, baseName, baseNameNoExtension, baseNameOther, exportDirAbs, extension, from, fromToMap, mirrorExt, newFile, newFileOther, otherBaseDir, otherFile, p, projectDir, sourceFileDidNotExist, sourceFileDidNotExistArr, to, toFromMap, _i, _j, _len, _len1, _ref, _results;
      if (srcDirMap == null) {
        srcDirMap = null;
      }
      sourceFileDidNotExistArr = [];
      if (!this.lastResult) {
        this.merge();
      }
      if (!this.lastResult.pathOrder) {
        throw new Error("there was no dependencies to export");
        return;
      }
      exportDirAbs = path.resolve(exportDir) || path.resolve(process.cwd(), exportDir);
      projectDir = process.cwd();
      _ref = this.lastResult.pathOrder;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p.indexOf(projectDir) !== 0) {
          throw new Error("" + p + " dependency not found each dependency should be in the project Dir: " + projectDir);
        }
        baseDir = path.dirname(p.slice(projectDir.length + 1));
        baseName = path.basename(p);
        extension = path.extname(p);
        baseNameNoExtension = baseName.slice(0, +(baseName.length - extension.length - 1) + 1 || 9e9);
        newFile = path.resolve(path.join(exportDirAbs, baseDir, baseName));
        fsExtra.ensureDirSync(path.dirname(newFile));
        fs.writeFileSync(newFile, p);
        if (srcDirMap) {
          for (mirrorExt in srcDirMap) {
            fromToMap = srcDirMap[mirrorExt];
            toFromMap = _.invert(fromToMap);
            for (to in toFromMap) {
              from = toFromMap[to];
              otherBaseDir = baseDir.replace(to, from);
              if (otherBaseDir === baseDir) {
                continue;
              }
              otherFile = path.join(path.resolve(process.cwd(), otherBaseDir), baseNameNoExtension + "." + mirrorExt);
              baseNameOther = path.basename(otherFile);
              if (fsExtra.existsSync(otherFile)) {
                newFileOther = path.resolve(path.join(exportDirAbs, otherBaseDir, baseNameOther));
                fsExtra.ensureDirSync(path.dirname(newFileOther));
                fs.writeFileSync(newFileOther, otherFile);
              } else {
                sourceFileDidNotExistArr.push(otherFile);
              }
              console.log(otherFile);
            }
          }
        }
      }
      _results = [];
      for (_j = 0, _len1 = sourceFileDidNotExistArr.length; _j < _len1; _j++) {
        sourceFileDidNotExist = sourceFileDidNotExistArr[_j];
        _results.push(console.log("WARNING source file did not exist: " + sourceFileDidNotExist));
      }
      return _results;
    };

    NodeUglifier.prototype.toString = function() {
      return this.lastResult.source.toString();
    };

    NodeUglifier.prototype.exportToFile = function(file) {
      var outDirRoot, outFileAbs, _this;
      _this = this;
      outFileAbs = path.resolve(file);
      fsExtra.ensureDirSync(path.dirname(outFileAbs));
      fs.writeFileSync(outFileAbs, this.toString());
      outDirRoot = path.dirname(outFileAbs);
      return _.keys(this.lastResult.filteredOutFilesObj).each(function(fileName) {
        var copyObj, newFile;
        copyObj = _this.lastResult.filteredOutFilesObj[fileName];
        newFile = path.resolve(outDirRoot, copyObj.pathRel);
        fsExtra.ensureDirSync(path.dirname(newFile));
        return fs.writeFileSync(newFile, copyObj.sourceMod);
      });
    };

    NodeUglifier.prototype.exportSourceMaps = function(file) {
      var dir, outFileAbs, sourceMapModulesOutFileName, sourceMapOutFileName, _this;
      _this = this;
      outFileAbs = path.resolve(file);
      sourceMapOutFileName = path.basename(outFileAbs) + ".map";
      sourceMapModulesOutFileName = path.basename(outFileAbs) + ".modules-map";
      dir = path.dirname(outFileAbs);
      fsExtra.ensureDirSync(dir);
      if (this.lastResult.sourceMapUglify != null) {
        fs.writeFileSync(path.join(dir, sourceMapOutFileName), this.lastResult.sourceMapUglify.replace(UGLIFY_SOURCE_MAP_TOKEN, sourceMapOutFileName));
      }
      return fs.writeFileSync(path.join(dir, sourceMapModulesOutFileName), JSON.stringify(_this.lastResult.sourceMapModules));
    };

    NodeUglifier.prototype.uglify = function(optionsIn) {
      var a, ast, options, res, source;
      if (optionsIn == null) {
        optionsIn = {};
      }
      if (!this.lastResult) {
        this.merge();
      }
      options = {
        mangle: true,
        compress: {
          drop_console: false,
          hoist_funs: true,
          loops: true,
          evaluate: true,
          conditionals: true
        },
        output: {
          comments: false
        },
        strProtectionLvl: 0
      };
      _.extend(options, optionsIn);
      if (!this.lastResult.source) {
        return;
      }
      source = this.toString();
      a = 1 + 1;
      res = UglifyJS.minify(source, _.extend({
        fromString: true,
        outSourceMap: UGLIFY_SOURCE_MAP_TOKEN
      }, options));
      this.lastResult.source = res.code;
      this.lastResult.sourceMapUglify = res.map;
      switch (options.strProtectionLvl) {
        case 1:
          ast = packageUtils.getAst(this.lastResult.source);
          this.lastResult.source = packageUtils.getSourceHexified(ast);
      }
      return this;
    };

    return NodeUglifier;

  })();

  module.exports = NodeUglifier;

}).call(this);

//# sourceMappingURL=NodeUglifier.map
