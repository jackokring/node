// Generated by CoffeeScript 1.7.1
(function() {
  var TotalObfuscator, cryptoUtils, fs, fsExtra, packageUtils, path, saltLength, sh, sugar, _;

  fsExtra = require('fs-extra');

  fs = require('fs');

  _ = require('underscore');

  sugar = require('sugar');

  path = require('path');

  sh = require('execSync');

  packageUtils = require('./libs/packageUtils');

  cryptoUtils = require('./libs/cryptoUtils');

  saltLength = 20;

  TotalObfuscator = (function() {
    function TotalObfuscator(mainFile, options) {
      var _i, _results;
      if (options == null) {
        options = {};
      }
      this.options = {
        leaveDirAsExternal: []
      };
      _.extend(this.options, options);
      this.mainFileAbs = path.resolve(mainFile);
      if (!fs.existsSync(this.mainFileAbs)) {
        throw new Error("main file not found");
      } else {
        console.log("processing main file: " + this.mainFileAbs);
      }
      this.salt = cryptoUtils.generateSalt(saltLength);
      this.hashAlgorithm = "sha1";
      this.wrappedSourceContainerName = "cachedModules";
      this.serialMappings = cryptoUtils.shuffleArray((function() {
        _results = [];
        for (_i = 0; _i <= 10000; _i++){ _results.push(_i); }
        return _results;
      }).apply(this));
      this._sourceCodes = {};
      this.lastResult = null;
    }

    TotalObfuscator.prototype.getSourceContainer = function(serial) {
      return this.wrappedSourceContainerName + "[" + this.serialMappings[serial] + "]";
    };

    TotalObfuscator.prototype.getRequireSubstitutionForMerge = function(serial) {
      return this.getSourceContainer(serial) + ".exports";
    };

    TotalObfuscator.prototype.addWrapper = function(source, serial) {
      var firstLine, lastLine, modulesArrayStr, secondLine;
      modulesArrayStr = this.getSourceContainer(serial);
      firstLine = modulesArrayStr + "={exports:{}};" + "\n";
      secondLine = "(function(module,exports) {";
      lastLine = "}).call(this," + modulesArrayStr + "," + modulesArrayStr + ".exports);";
      return "\n" + firstLine + secondLine + source + lastLine;
    };

    TotalObfuscator.prototype.combine = function() {
      var firstLine, r, recursiveSourceGrabber, _this;
      _this = this;
      firstLine = "var " + this.wrappedSourceContainerName + "=[];";
      r = firstLine;
      recursiveSourceGrabber = function(filePath) {
        var ast, isReplaced, otherSerial, pathSaltedHash, requireStatement, requireStatements, serial, source, sourceMod, withTheOtherQuotation, _i, _len;
        source = packageUtils.readFile(filePath).toString();
        pathSaltedHash = cryptoUtils.getSaltedHash(filePath, _this.hashAlgorithm, _this.salt);
        if (_this._sourceCodes[pathSaltedHash] == null) {
          _this._sourceCodes[pathSaltedHash] = {
            source: source,
            serial: _.keys(_this._sourceCodes).length
          };
          console.log(filePath + " added to sources ");
        }
        serial = _this._sourceCodes[pathSaltedHash].serial;
        ast = packageUtils.getAst(source);
        requireStatements = packageUtils.getRequireStatements(ast, filePath);
        requireStatements.each(function(o, i) {
          return requireStatements[i] = _.extend(o, {
            pathSaltedHash: cryptoUtils.getSaltedHash(o.path, _this.hashAlgorithm, _this.salt)
          });
        });
        sourceMod = source;
        for (_i = 0, _len = requireStatements.length; _i < _len; _i++) {
          requireStatement = requireStatements[_i];
          if (_this._sourceCodes[requireStatement.pathSaltedHash] == null) {
            recursiveSourceGrabber(requireStatement.path);
          }
          if (_this._sourceCodes[requireStatement.pathSaltedHash] == null) {
            throw new Error(" internal should not happen 1");
          }
          otherSerial = _this._sourceCodes[requireStatement.pathSaltedHash].serial;
          isReplaced = false;
          sourceMod = sourceMod.replace(requireStatement.text, function(token) {
            isReplaced = true;
            return _this.getRequireSubstitution(otherSerial);
          });
          if (!isReplaced) {
            withTheOtherQuotation = requireStatement.text;
            if (withTheOtherQuotation.indexOf("'") !== -1) {
              withTheOtherQuotation = withTheOtherQuotation.replace(/[']/ig, '"');
            } else {
              withTheOtherQuotation = withTheOtherQuotation.replace(/["]/ig, "'");
            }
            sourceMod = sourceMod.replace(withTheOtherQuotation, function(token) {
              isReplaced = true;
              return _this.getRequireSubstitution(otherSerial);
            });
          }
          if (!isReplaced) {
            throw new Error(requireStatement.text + " was not replaced with " + _this.getRequireSubstitution(otherSerial));
          }
        }
        _this._sourceCodes[pathSaltedHash].sourceMod = sourceMod;
        if (serial > 0) {
          _this._sourceCodes[pathSaltedHash].sourceModWrapped = _this.addWrapper(sourceMod, serial);
        } else {
          _this._sourceCodes[pathSaltedHash].sourceModWrapped = sourceMod;
        }
        return r = r + _this._sourceCodes[pathSaltedHash].sourceModWrapped;
      };
      recursiveSourceGrabber(this.mainFileAbs);
      return this.lastResult = r;
    };

    return TotalObfuscator;

  })();

  new TotalObfuscator("lib_compiled/test/test.js").combine();

}).call(this);

//# sourceMappingURL=totalObfuscator.map
